// graph {
//     a -- b;
//     b -- c;
// }

// digraph {
//     A -> B;
// }

// digraph {
//     A -> B -> C -> D;
//     C -> E -> F;
//     F -> B;
// }

// digraph {
//     Tinos          [ fontname="Tinos" ];
//     Handlee        [ fontname="Handlee" ];
//     "Sedgwick Ave" [ fontname="Sedgwick Ave" ];
//     "*also Sedgwick*";
// }


/**************************************
 * weight
 **************************************/
// digraph {
//     a -> b[label="0.2", weight="0.2"];
//     a -> c[label="0.4", weight="0.4"];
//     c -> b[label="0.6", weight="0.6"];
//     c -> e[label="0.6", weight="0.6"];
//     e -> e[label="0.1", weight="0.1"];
//     e -> b[label="0.7", weight="0.7"];
// }

/**************************************
 * Color
 **************************************/
// graph {
//     a -- b[color=red, penwidth=3.0];
//     b -- c;            
//     c -- d[color=red, penwidth=3.0];
//     d -- e;            
//     e -- f;            
//     a -- d;            
//     b -- d[color=red, penwidth=3.0];
//     c -- f[color=red, penwidth=3.0];
// }
//
// graph {
//     a -- b -- d -- c -- f[color=red, penwidth=3.0];
//     b -- c;
//     d -- e;
//     e -- f;
//     a -- d;
// }
//
// digraph {
//     rankdir="BT"
//     
//     bgcolor="#222222"
//     
//     // defaults for edges and nodes can be specified
//     node [ color="#ffffff" fontcolor="#ffffff" ]
//     edge [ color="#ffffff" ]
//     
//     2 [fillcolor="#f22430" style=filled color="#000000" fontcolor="#000000"]
//     4 [fillcolor="#f22430" style=filled color="#000000" fontcolor="#000000"]
//     5 [fillcolor="#f22430" style=filled color="#000000" fontcolor="#000000"]
//     
//     1 -> 2
//     1 -> 3
//     1 -> 5
//     2 -> 4 [color="#f22430"]
//     2 -> 6 [color="#f22430"]
//     3 -> 4 
//     3 -> 7 
//  
// }

// graph {
//     rankdir=LR; // Left to Right, instead of Top to Bottom
//     a -- { b c d };
//     b -- { c e };
//     c -- { e f };
// }
//
// graph {
//     rankdir=LR;
//     a -- { b c d }; b -- { c e }; c -- { e f }; d -- { f g }; e -- h;
//     f -- { h i j g }; g -- k; h -- { o l }; i -- { l m j }; j -- { m n k };
//     k -- { n r }; l -- { o m }; m -- { o p n }; n -- { q r };
//     o -- { s p }; p -- { s t q }; q -- { t r }; r -- t; s -- z; t -- z;
//     { rank=same; b, c, d }
//     { rank=same; e, f, g }
//     { rank=same; h, i, j, k }
//     { rank=same; l, m, n }
//     { rank=same; o, p, q, r }
//     { rank=same; s, t }
// }

/**************************************
 * 직교
 **************************************/
// digraph Orthogonal {
//     graph [label="Orthogonal edges", splines=ortho, nodesep=0.8]
//     node [shape=box]
//     a->{b c}
//     b->{d e}
//     c->{f g}
// }


/**************************************
 * Flow chart
 **************************************/
// digraph {
//     label="How to make sure 'input' is valid"
// 
//     start    [shape="box"          , style=rounded];
//     end      [shape="box"          , style=rounded];
//     if_valid [shape="diamond"      , style=""];
//     message  [shape="parallelogram", style=""];
//     input    [shape="parallelogram", style=""];
// 
//     start     -> input;
//     input     -> if_valid;
//     if_valid  -> message[label="no"];
//     if_valid  -> end    [label="yes"];
//     message   -> input;
// }

/**************************************
 * Since all node mentioning is declarative,            
 * you can easily put labels in a different section than
 * the structure of your graph:                         
 **************************************/
// * digraph {
//     label="How to make sure 'input' is valid"
// 
//     start    [shape="box"          , style=rounded];
//     end      [shape="box"          , style=rounded];
//     if_valid [shape="diamond"      , style=""];
//     message  [shape="parallelogram", style=""]
//     input    [shape="parallelogram", style=""]
// 
//     start    -> input;
//     input    -> if_valid;
//     if_valid -> message[label="no"];
//     if_valid -> end    [label="yes"];
//     message  -> input;
// 
//     if_valid [label="Is input\nvalid?"]
//     message  [label="Show\nmessage"]
//     input    [label="Prompt\nfor input"]
// }

/**************************************
 * Moreover, you can use the node keyword  
 * to declare attributes for sets of nodes:
 **************************************/
// digraph {
//     label="How to make sure 'input' is valid";
// 
//     node[shape="box"          , style="rounded"]
//        start; end;
//       
//     node[shape="parallelogram", style=""]
//        message; input;
//
//     node[shape="diamond"      , style=""]
//        if_valid;
// 
//     start    -> input;
//     input    -> if_valid;
//     if_valid -> message [label="no"];
//     if_valid -> end     [label="yes"];
//     message  -> input;     
// 
//     if_valid [label="Is input\nvalid?"]
//     message  [label="Show\nmessage"]
//     input    [label="Prompt\nfor input"]
// }


/**************************************
 * You can use ranking of nodes                                               
 * to make sure nodes are ranked equally so they are put next to each other: 
 **************************************/
// digraph {
//     label="How to make sure 'input' is valid";
//     node[shape="box"          , style="rounded"]
//        start; end;
//     node[shape="parallelogram", style=""]
//        message; input;
//     node[shape="diamond"      , style=""]
//        if_valid;
//     start    -> input;
//     input    -> if_valid;
//     if_valid -> message [label="no"];
//     if_valid -> end     [label="yes"];
//     message  -> input;     
//     {rank=same; message input}
// }

/**************************************
 * record
 * Nodes with shape=record are treated specially.
 * These are useful for displaying tables and object layouts.
 * Note that you need to use ports,
 * signified by <angle-brackets> to create edges to and from records.
 **************************************/
// digraph {
//     rankdir=LR;
//     node [ shape=record ];
//     
//     struct1 [
//         label = "a|b|<port1>c";
//     ];
//  
//     struct2 [
//         label = "a|{<port2>b1|b2}|c";
//     ];
//  
//  
//     struct1:port1 -> struct2:port2 [ label="xyz" ];
// }

/**************************************
 * UML class diagrams.
 **************************************/
// digraph {
//     rankdir="RL"
//    
//     // fields in the label are separated by a |
//     // ending a line in \l left aligns it
//     Hero [ 
//         shape="record"
//         label="Hero|+ health : int\l|+ save(k : Kingdom) : bool\l"
//     ]
//    
//     // do whatever you want with whitespace
//     Villain [
//         shape="record"
//         label="Villain|+ health : int\l|+ brood() : void\l"
//     ]
//     Character [ shape="record" ]
//    
//     Hero    -> Character [ arrowhead="empty" ]
//     Villain -> Character [ arrowhead="empty" ]
// }

// If your rankdir is vertical,
// then you need to use {} to change the record type's direction.
// digraph {
//     rankdir="BT"
//    
//     Hero [ 
//         shape="record"
//         label="{Hero|+ health : int\l|+ save(k : Kingdom) : bool\l}"
//     ]
//     Villain [
//         shape="record"
//         label="{Villain|+ health : int\l|+ brood() : void\l}"
//     ]
//     Character [ shape="record" ]
//    
//     Hero    -> Character [ arrowhead="empty" ]
//     Villain -> Character [ arrowhead="empty" ]
// }

/**************************************
 * subgraph
 **************************************/
// digraph {
//     subgraph cluster_0 {
//         label="Subgraph A";
//         a -> b;
//         b -> c;
//         c -> d;
//     }
//     subgraph cluster_1 {
//         label="Subgraph B";
//         a -> f;
//         f -> c;
//     }
// }

/**************************************
 * subgraph + splines=line;
 **************************************/
// graph {
//     splines=line;
//     subgraph cluster_0 {
//         label="Subgraph A";
//         a; b; c
//     }
//     subgraph cluster_1 {
//         label="Subgraph B";
//         d; e;
//     }
//     a -- e;
//     a -- d;
//     b -- d;
//     b -- e;
//     c -- d;
//     c -- e;
// }

// digraph {
//     rankdir="LR"
//     // the normal ranking algorithm doesn't know what to do with clusters with rank="same".
//     // If you opt in to the 'new' ranking algorithm, it works as expected.
//     newrank="true"
//     
//     A -> B
//     A -> C
//     B -> C
//     C -> D
//     
//     subgraph cluster_subs {
//         label="Bs and Cs"
//         rank="same"
//         B
//         C
//     }
// }

/**************************************
 * Cluster(or Subgraph)
 * You can group related nodes by putting them in a subgraph
 * whose name begins with cluster_.
 **************************************/
// digraph {
//     node [ fontname="Handlee" ];
//     subgraph cluster_frontend {
//         label="*Frontend*";
//         React;
//         Bootstrap;
//     }
//         
//     subgraph cluster_backend {
//         label="*Backend*";
//         expressjs;
//         "aws-sdk";
//     }
//    
//     React     -> expressjs;
//     expressjs -> "aws-sdk";
// }

// We'll add constraint=false to the edge between expressjs and aws-sdk
// to let Graphviz know that
// the edge doesn't imply that expressjs should be ranked higher in precedence:
// digraph {
//   node [ fontname="Handlee" ];
//   subgraph cluster_frontend {
//       label="*Frontend*";
//       React;
//       Bootstrap;
//   }
//       
//   subgraph cluster_backend {
//       label="*Backend*";
//       expressjs;
//       "aws-sdk";
//   }
//  
//   React     -> expressjs;
//   expressjs -> "aws-sdk" [constraint=false];
// }

// Nested Clusters
// digraph {
//     node [ fontname="Handlee" ];
//     subgraph cluster_website {
//         label="*Website*";
//         
//         subgraph cluster_frontend {
//             label="*Frontend*";
//             React;
//             Bootstrap;
//         }
//         
//         subgraph cluster_backend {
//             label="*Backend*";
//             expressjs;
//             "aws-sdk";
//         }
//     }
//      
//     subgraph cluster_aws {
//         label="*AWS*";
//         
//         DynamoDb;
//         S3;
//     }
//      
//     React     -> expressjs;
//     expressjs -> "aws-sdk" [constraint=false];
//     "aws-sdk" -> S3;
//     "aws-sdk" -> DynamoDb;
// }

// If you'd like your arrow to start or stop at the cluster boundary,
// you have to set compound=true and use the lhead or ltail attributes on the edge:
// digraph {
//     compound=true;
//     node [ fontname="Handlee" ];
//     subgraph cluster_website {
//         label="*Website*";
//         
//         subgraph cluster_frontend {
//             label="*Frontend*";
//             React;
//             Bootstrap;
//         }
//         
//         subgraph cluster_backend {
//             label="*Backend*";
//             expressjs;
//             "aws-sdk";
//         }
//     }
//     
//     subgraph cluster_aws {
//         label="*AWS*";
//         DynamoDb;
//         S3;
//     }
//     
//     React     -> expressjs;
//     expressjs -> "aws-sdk" [constraint=false];
//     "aws-sdk" -> S3        [lhead=cluster_aws];
// }

